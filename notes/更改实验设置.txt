测试比较了三种异常分数计算方法，和训练时一致

Self.dist - R**2:  0.71 且热力图颜色不分明

直接用self.dist 0.803 热力图颜色不分明

abs(self.dist - self.R ** 2) 0.55

计算热力图时处理一下极大值,处理了确实auc提高了，bce降低了

平均半径还是分位点？ 测试后发现采用分位点计算svdd loss会加速半径减小并提高了auc

并且标签里的背景训练时为0，在计算svdd_loss均忽略

----------------------------------------
采用最新的svdd_loss计算方式以及异常分数计算方式重新跑下之前的实验。

但是发现这个设置在农业数据集上water上表现一般, 重新更改

训练依然采用最大的dist-R**2
推理在原来abs(self.dist - R**2)的基础上，加上内部的*0.5，原理是将整个区域分为三个部分，内部里面的，
内部靠边的，外部靠边的，外部远离的

画一个异常得分图，这个很重要。这个设置也不对

发现water和deep globe基本都是没有球面外的，但是water是越靠近原点越异常， deep globe则相反

water更换为anomaly_map - self.R ** 2试试 峰值太低，表现一般

deepglobe维持绝对值训练看看,会有很高的auc但是可视化不好。需要找一个度量指标，指出哪一个参数更好

没想到还没用到指标，仅仅是在计算dist得时候采用了q=0.98分位点，就取得了很好的效果，这个一定要加在实验细节那部分。同时说明所有算法采取了相同的归一化方式
此外，将mseoad一开始dataset加载时将影像异常部分乘0改成了对异常部分的descriptor乘0，此外对transformed_image_descriptors也做类似处理
此外，增加参数zero_image对ae，gan这些还是将影像异常部分乘0，注意这个参数
此外，每次迭代采用的距离计算取均值mean而非最大值max;
riad和tiae注意参数act_ac_tiae以及数据集定义的is_tiae

目前采取的损失比例1：1，

数据增强替换为直接用异常数据，且加一个靠近原点的loss约束,发现直接用异常数据好很多，点也很高。

但是这样的问题是引入了额外的数据，能否不引入额外数据，单纯打乱现有数据试试.问题是bce很低，再次测试max试试

更改为max后，bce显著降低，但auc也有所降低。
此外，发现如果把with no_grad去掉后，效果更好，
发现同样的代码，不同型号的gpu训练出来有差别，所以比较要在相同GPU上

测试0.98分位点加取消no-no-no_grad不太行不如max的，可能是max后不会受到极值点影响这么大


感觉对比损失不太稳定，要不试下余弦loss？余弦loss只和方向有关，和距离无关，模型还是会坍塌

l2的对比损失比例没多大关系，对比损失的数量级决定了svdd loss的数量级，但半径没啥差别

试试对比损失l2采取0.5分位点的效果，效果最优，且比0.1分位点高

发现计算l2损失代码有问题，改了代码后重新测试,之前计算分位数没有忽略背景

测试如果打乱顺序后，再加这个数据增强会怎么样

优化过程发现其实优化哪一项和数量级关系不大，模型会先优化容易的，后优化难的.[也不是，只是那个无法优化]

constacct_loss 0.02和min差不多

其实我们也是可以做消融实验的，
    消融计算svdd_loss的方式， 0.98， max， 
    消融数据增强方式（随机打乱，单个增强方式）
    消融对比损失比例

打乱顺序后再加数据增强没啥用，去掉

好像采取min或者0.5都会坍塌掉？测试下mean,因为这些对比损失太难优化，模型一直在优化svdd loss

为了坍塌这个问题，改对比损失计算方式为abs(loss - R**2)，0.5的分位点优于0.9
解决了，再给对比损失加个权就可以了。ASD最美的地方是构造了一个矛盾，这个矛盾得到了新的异常分数
不对，还是会坍塌，感觉原因是加的权不够，采用动态权重(self.initial_R/self.R)*试试

还是原来的方式吧，这些还是会坍塌

改回了原来的得到descriptor后mask背景区域，以及对比损失计算方式，对于transormed_features没有去mask

发现water这种，异常分数取abs比较好，而对于deepGlobe 农业那一类，则不是


为了测试是否可以最后取聚类中心，然后统一地物的异常计算方式。在water和deepGlobe 农业那一类测试
更改了runner_mseoad文件，test时候使用训练数据计算中心，而且异常分数定义为与新中心的距离

直接推理一个0.65，一个0.88。重新训练试试
发现这种是每5个epoch更新一次中心，而且计算异常分数时计算与cluster中心距离的方式比较好。
但是发现这种方式会得到较高的bce，如果训练时候不更新中心呢,差不了多少。还是更新C吧，这样原理上讲得过去点

已修改回去

为了测试对比损失得消融，在water和deepGlobe 农业那一类测试
对比损失乘0试试
发现前几个epoch的话，由于本身对比损失值就比较小，几乎没有什么影响

为了调大对比损失值，那就让半径尽快的减小，试试先不用对比损失，取距离平均值构造svdd_loss
发现和之前一样的问题，BCE值较高

目前在测试mean+更新中心的deep Globe农业精度，算了，先把deepGlobe侧完，找个精度高的去消融

loss分析
    alpha， beta， svdd_loss-max, svdd_mean, svdd_loss-0.98, constrac_mean, constrac_min, constacr_max-0.5, 


为了测试在test时候是否可以找到一个标准，决定是求与原点的距离还是超球面边界的距离。使用water之前训练的参数和
deepglobe训练的农业数据的参数

更改test流程，原始test命名为test_old

结论是没有找见这样的标准，确实离原点更近

发现真的是否更改中心差别挺大的.

选取每次保存最大值后，更新时取最大值的0.9分位点

谷歌发布了近实时的10-m分辨率的全球土地利用数据,这个可以用在异常分割上